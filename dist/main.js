/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/main.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/bigmat3d.js":
/*!*************************!*\
  !*** ./src/bigmat3d.js ***!
  \*************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return BigMat3D; });\nclass BigMat3D {\r\n    constructor(diagSize) {\r\n      this.size = diagSize;\r\n      this.data = new Float32Array(Math.max(diagSize, 16) * 9);\r\n      this.posns = new Uint16Array(Math.max(diagSize, 16) * 2);\r\n      for (let i = 0, j = 0; i < diagSize; ++i, j += 2) {\r\n        this.posns[j] = this.posns[j + 1] = i;\r\n      }\r\n    }\r\n\r\n    initDiag(f) {\r\n      for (let i = 0, pi = 0, mi = 0; i < this.size; ++i, pi += 2, mi += 9) {\r\n        let d = this.posns[pi] === this.posns[pi + 1] ? f : 0.0;\r\n        for (let r = 0; r < 3; ++r) {\r\n          for (let c = 0; c < 3; ++c) {\r\n            this.data[mi + r * 3 + c] = r === c ? d : 0.0;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    zero() {\r\n      for (let i = 0, l = this.size * 9; i < l; ++i) {\r\n        this.data[i] = 0.0;\r\n      }\r\n    }\r\n\r\n    capacity() {\r\n      return Math.floor(this.data.length / 9);\r\n    }\r\n\r\n    grow_() {\r\n      let nextData = new Float32Array(this.data.length * 2);\r\n      for (let i = 0; i < this.data.length; ++i) {nextData[i] = this.data[i];}\r\n      this.data = nextData;\r\n      let nextPosns = new Uint16Array(this.posns.length * 2);\r\n      for (let i = 0; i < this.posns.length; ++i) {nextPosns[i] = this.posns[i];}\r\n      this.posns = nextPosns;\r\n    }\r\n\r\n    push(r, c) {\r\n      if (this.size + 1 >= this.capacity()) {this.grow_();}\r\n      let nextIdx = this.size * 9;\r\n      let nextPosIdx = this.size * 2;\r\n      this.posns[nextPosIdx + 0] = r;\r\n      this.posns[nextPosIdx + 1] = c;\r\n      this.data[nextIdx + 0] = 0.0;this.data[nextIdx + 1] = 0.0;this.data[nextIdx + 2] = 0.0;\r\n      this.data[nextIdx + 3] = 0.0;this.data[nextIdx + 4] = 0.0;this.data[nextIdx + 5] = 0.0;\r\n      this.data[nextIdx + 6] = 0.0;this.data[nextIdx + 7] = 0.0;this.data[nextIdx + 8] = 0.0;\r\n      ++this.size;\r\n      return nextIdx;\r\n    }\r\n\r\n    forEach(fn, self) {\r\n      for (let i = 0, ii = 0, pi = 0; i < this.size; ++i, ii += 9, pi += 2) {\r\n        fn.call(self, ii, this.posns[pi], this.posns[pi + 1], i, this);\r\n      }\r\n    }\r\n\r\n    nanCheck() {\r\n      if (DEBUG) {\r\n        for (let i = 0; i < this.size * 9; ++i) {\r\n          let x = this.data[i];\r\n          if (+x !== x) {console.assert(\"NaNCheck failed\");debugger;}\r\n        }\r\n      }\r\n    }\r\n\r\n    pushFront(r, c) {\r\n      if (this.size + 1 >= this.capacity()) {\r\n        this.grow_();\r\n      }\r\n      this.size++;\r\n      for (let totalSize = this.size * 9, i = totalSize - 1; i >= 9; --i) {\r\n        this.data[i] = this.data[i - 9];\r\n      }\r\n\r\n      for (let i = this.size * 2 - 1; i >= 2; --i) {\r\n        this.posns[i] = this.posns[i - 2];\r\n      }\r\n\r\n      for (let i = 0; i < 9; ++i) {\r\n        this.data[i] = 0.0;\r\n      }\r\n\r\n      this.posns[0] = r;\r\n      this.posns[1] = c;\r\n      return 0;\r\n    }\r\n\r\n    clearRow(index) {\r\n      let j = 0;\r\n      for (let i = 0, l = this.size; i < l; ++i) {\r\n        if (this.posns[i * 2] !== index) {\r\n          this.posns[j * 2 + 0] = this.posns[i * 2 + 0];\r\n          this.posns[j * 2 + 1] = this.posns[i * 2 + 1];\r\n          let mi = i * 9,mj = j * 9;\r\n          for (let mii = 0; mii < 9; ++mii) {\r\n            this.data[mj + mii] = this.data[mi + mii];\r\n          }\r\n          j++;\r\n        }\r\n      }\r\n      this.size = j;\r\n    }}\n\n//# sourceURL=webpack:///./src/bigmat3d.js?");

/***/ }),

/***/ "./src/bigvec3d.js":
/*!*************************!*\
  !*** ./src/bigvec3d.js ***!
  \*************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return BigVec3D; });\nclass BigVec3D {\r\n    constructor(initSize, tight = true) {\r\n      this.size = initSize;\r\n      this.data = new Float32Array(initSize * 3);\r\n    }\r\n\r\n    nanCheck() {\r\n      if (DEBUG) {\r\n        for (let i = 0; i < this.size * 3; ++i) {\r\n          let x = this.data[i];\r\n          if (+x !== x) {console.assert(\"NaNCheck failed\");debugger;}\r\n        }\r\n      }\r\n    }\r\n\r\n    copy(other) {\r\n      console.assert(this.size === other.size);\r\n      for (let i = 0; i < this.size * 3; ++i) {\r\n        this.data[i] = other.data[i];\r\n      }\r\n    }\r\n\r\n    forEach(fn, self) {\r\n      for (let i = 0, ii = 0; i < this.size; ++i, ii += 3) {\r\n        fn.call(self, this.data[ii], this.data[ii + 1], this.data[ii + 2], i, this);\r\n      }\r\n    }\r\n\r\n    init(x, y, z) {\r\n      for (let i = 0; i < this.data.length; i += 3) {\r\n        this.data[i + 0] = x;\r\n        this.data[i + 1] = y;\r\n        this.data[i + 2] = z;\r\n      }\r\n    }\r\n\r\n    zero() {\r\n      for (let i = 0, l = this.size * 3; i < l; ++i) {\r\n        this.data[i] = 0.0;\r\n      }\r\n    }}\n\n//# sourceURL=webpack:///./src/bigvec3d.js?");

/***/ }),

/***/ "./src/cloth.js":
/*!**********************!*\
  !*** ./src/cloth.js ***!
  \**********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Cloth; });\n/* harmony import */ var _spring__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./spring */ \"./src/spring.js\");\n/* harmony import */ var _bigmat3d__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./bigmat3d */ \"./src/bigmat3d.js\");\n/* harmony import */ var _bigvec3d__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./bigvec3d */ \"./src/bigvec3d.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils */ \"./src/utils.js\");\n\r\n\r\n\r\n\r\n\r\n\r\nlet DEBUG = false;\r\nSim.DEBUG = DEBUG;\r\nlet Options = {\r\n    gravity: -9.8,\r\n    structK: 100000,\r\n    shearK: 5000,\r\n    bendK: 1000,\r\n    dampSpring: 10,\r\n    dampAir: 5,\r\n    clothWidth: 16,\r\n    clothHeight: 16,\r\n    mass: 1.0,\r\n    sleepThreshold: 0.001,\r\n    sleepCount: 100,\r\n    tension: 1.0,\r\n    timeStep: 0.016,\r\n    pinned: {\r\n        bottomLeft: false,\r\n        bottomRight: false,\r\n        topLeft: true,\r\n        topRight: true\r\n    },\r\n    dynamicWind: true,\r\n    wind: [0.0, 0.0, 0.0] // if not dynamic\r\n  };\r\n\r\n  const StructSpring = 0;\r\n  const ShearSpring = 1;\r\n  const BendSpring = 2;\r\n  const SpringConstants = [Options.structK, Options.shearK, Options.bendK];\r\n\r\n\r\nclass Cloth {\r\n    constructor(w, h, size) {\r\n\r\n      let springs = [];\r\n      let points = [];\r\n      let texcoords = []\r\n      // let quads = [];\r\n      let tris = [];\r\n\r\n      _utils__WEBPACK_IMPORTED_MODULE_3__[\"default\"].foreach2d(w, h, (i, j) => {\r\n        points.push((j / (w - 1.0) - 0.5) * size, (i / (w - 1.0) - 0.5) * size, 0.0);\r\n        texcoords.push(j / (w - 1.0), i / (h - 1.0));\r\n      });\r\n\r\n      let r = 0.0;\r\n      {\r\n        let dx = points[0] - points[3];\r\n        let dy = points[1] - points[4];\r\n        let dz = points[2] - points[5];\r\n        r = Math.sqrt(dx * dx + dy * dy + dz * dz) * Options.tension;\r\n      }\r\n\r\n      _utils__WEBPACK_IMPORTED_MODULE_3__[\"default\"].foreach2d(w, h, (i, j) => {if (i < h - 1) springs.push(new _spring__WEBPACK_IMPORTED_MODULE_0__[\"default\"](StructSpring, i * w + j, (i + 1) * w + j, r));});\r\n      _utils__WEBPACK_IMPORTED_MODULE_3__[\"default\"].foreach2d(w, h, (i, j) => {if (j < w - 1) springs.push(new _spring__WEBPACK_IMPORTED_MODULE_0__[\"default\"](StructSpring, i * w + j, i * w + (j + 1), r));});\r\n\r\n      _utils__WEBPACK_IMPORTED_MODULE_3__[\"default\"].foreach2d(w, h, (i, j) => {if (j < w - 1 && i < h - 1) springs.push(new _spring__WEBPACK_IMPORTED_MODULE_0__[\"default\"](ShearSpring, i * w + j, (i + 1) * w + (j + 1), r * Math.sqrt(2)));});\r\n      _utils__WEBPACK_IMPORTED_MODULE_3__[\"default\"].foreach2d(w, h, (i, j) => {if (j > 0 && i < h - 1) springs.push(new _spring__WEBPACK_IMPORTED_MODULE_0__[\"default\"](ShearSpring, i * w + j, (i + 1) * w + (j - 1), r * Math.sqrt(2)));});\r\n      _utils__WEBPACK_IMPORTED_MODULE_3__[\"default\"].foreach2d(w, h, (i, j) => {if (i < h - 2) springs.push(new _spring__WEBPACK_IMPORTED_MODULE_0__[\"default\"](BendSpring, i * w + j, (i + 2) * w + j, r * 2.0));});\r\n      _utils__WEBPACK_IMPORTED_MODULE_3__[\"default\"].foreach2d(w, h, (i, j) => {if (j < w - 2) springs.push(new _spring__WEBPACK_IMPORTED_MODULE_0__[\"default\"](BendSpring, i * w + j, i * w + (j + 2), r * 2.0));});\r\n\r\n      _utils__WEBPACK_IMPORTED_MODULE_3__[\"default\"].foreach2d(w - 1, h - 1, (i, j) => {\r\n        let v0 = (i + 0) * w + (j + 0),v1 = (i + 0) * w + (j + 1);\r\n        let v2 = (i + 1) * w + (j + 1),v3 = (i + 1) * w + (j + 0);\r\n        tris.push(v0, v1, v2, v2, v3, v0);\r\n      });\r\n\r\n      let n = points.length / 3;\r\n\r\n      this.wind = new Float32Array([0.0, 0.0, 0.0]);\r\n\r\n      this.Xb = new Float32Array(n * 3); // pos\r\n      this.M = new Float32Array(n); // mass\r\n\r\n      this.X = new _bigvec3d__WEBPACK_IMPORTED_MODULE_2__[\"default\"](n);\r\n      this.X.data = new Float32Array(points);\r\n\r\n      this.V = new _bigvec3d__WEBPACK_IMPORTED_MODULE_2__[\"default\"](n); // vel\r\n      this.N = new _bigvec3d__WEBPACK_IMPORTED_MODULE_2__[\"default\"](n); // normals\r\n      this.P = new _bigvec3d__WEBPACK_IMPORTED_MODULE_2__[\"default\"](n); // pressure\r\n      this.F = new _bigvec3d__WEBPACK_IMPORTED_MODULE_2__[\"default\"](n); // force\r\n      this.dV = new _bigvec3d__WEBPACK_IMPORTED_MODULE_2__[\"default\"](n); // velocity delta\r\n\r\n      this.A = new _bigmat3d__WEBPACK_IMPORTED_MODULE_1__[\"default\"](n); // solution matrix\r\n      this.dFdX = new _bigmat3d__WEBPACK_IMPORTED_MODULE_1__[\"default\"](n);\r\n      this.dFdV = new _bigmat3d__WEBPACK_IMPORTED_MODULE_1__[\"default\"](n);\r\n\r\n      this.tmpB = new _bigvec3d__WEBPACK_IMPORTED_MODULE_2__[\"default\"](n);\r\n      this.tmpdFdXmV = new _bigvec3d__WEBPACK_IMPORTED_MODULE_2__[\"default\"](n);\r\n      this.tmpQ = new _bigvec3d__WEBPACK_IMPORTED_MODULE_2__[\"default\"](n);\r\n      this.tmpD = new _bigvec3d__WEBPACK_IMPORTED_MODULE_2__[\"default\"](n);\r\n      this.tmpT = new _bigvec3d__WEBPACK_IMPORTED_MODULE_2__[\"default\"](n);\r\n      this.tmpR = new _bigvec3d__WEBPACK_IMPORTED_MODULE_2__[\"default\"](n);\r\n\r\n      this.springs = springs;\r\n      this.springs.forEach(s => {\r\n        s.iab = this.A.size;this.A.push(s.a, s.b);this.dFdX.push(s.a, s.b);this.dFdV.push(s.a, s.b);\r\n        s.iba = this.A.size;this.A.push(s.b, s.a);this.dFdX.push(s.b, s.a);this.dFdV.push(s.b, s.a);\r\n      });\r\n\r\n      // this.H = [];\r\n\r\n      for (let i = 0; i < n; ++i) {\r\n        this.M[i] = Options.mass;\r\n      }\r\n\r\n      this.uvs = new Float32Array(texcoords);\r\n\r\n      this.tris = new Uint16Array(tris);\r\n\r\n      this.S = new _bigmat3d__WEBPACK_IMPORTED_MODULE_1__[\"default\"](0);\r\n\r\n      if (Options.pinned.bottomLeft) this.pointStatusSet(0, 1);\r\n      if (Options.pinned.bottomRight) this.pointStatusSet(w - 1, 1);\r\n      if (Options.pinned.topLeft) this.pointStatusSet((h - 1) * w, 1);\r\n      if (Options.pinned.topRight) this.pointStatusSet(h * w - 1, 1);\r\n    }\r\n\r\n    pointStatusSet(index, op) {\r\n      if (index < 0 || index > this.X.size) return -1;\r\n      let st = false;\r\n      for (let i = 0, l = this.S.size * 2; i < l; i += 2) {\r\n        if (this.S.posns[i] === index) {st = true;break;}\r\n      }\r\n      if (st && (op === 0 || op === 2)) {\r\n        this.S.clearRow(index);\r\n        st = false;\r\n      }\r\n      if (!st && (op === 1 || op === 2)) {\r\n        this.S.pushFront(index, index);\r\n        this.V.data[index * 3 + 0] = 0.0;\r\n        this.V.data[index * 3 + 1] = 0.0;\r\n        this.V.data[index * 3 + 2] = 0.0;\r\n        st = true;\r\n      }\r\n      this.M[index] = st ? 0.0 : Options.mass;\r\n    }\r\n    // just average normal for each face.\r\n    calcNormals() {\r\n      this.N.init(0, 0, 0);\r\n      let N = this.N.data,X = this.X.data;\r\n      let tris = this.tris; //, quads = this.quads;\r\n      for (let i = 0, l = tris.length; i < l; i += 3) {\r\n        let v0i = tris[i + 0] * 3,v1i = tris[i + 1] * 3,v2i = tris[i + 2] * 3;\r\n\r\n        let v0x = X[v0i + 0],v0y = X[v0i + 1],v0z = X[v0i + 2];\r\n        let v1x = X[v1i + 0],v1y = X[v1i + 1],v1z = X[v1i + 2];\r\n        let v2x = X[v2i + 0],v2y = X[v2i + 1],v2z = X[v2i + 2];\r\n\r\n        let d10x = v1x - v0x,d10y = v1y - v0y,d10z = v1z - v0z;\r\n        let d21x = v2x - v1x,d21y = v2y - v1y,d21z = v2z - v1z;\r\n\r\n        let nx = d10y * d21z - d10z * d21y;\r\n        let ny = d10z * d21x - d10x * d21z;\r\n        let nz = d10x * d21y - d10y * d21x;\r\n        N[v0i + 0] += nx;N[v0i + 1] += ny;N[v0i + 2] += nz;\r\n        N[v1i + 0] += nx;N[v1i + 1] += ny;N[v1i + 2] += nz;\r\n        N[v2i + 0] += nx;N[v2i + 1] += ny;N[v2i + 2] += nz;\r\n      }\r\n      for (let i = 0, ii = 0, l = this.N.size; i < l; ++i, ii += 3) {\r\n        let x = N[ii + 0],y = N[ii + 1],z = N[ii + 2];\r\n        let il = 1.0 / Math.sqrt(x * x + y * y + z * z);\r\n        N[ii + 0] = x * il;\r\n        N[ii + 1] = y * il;\r\n        N[ii + 2] = z * il;\r\n      }\r\n    }\r\n\r\n    calcForces() {\r\n      this.calcNormals();\r\n      this.dFdX.zero();\r\n      this.dFdV.initDiag(0.0);\r\n      this.F.init(0, Options.gravity, 0);\r\n      let [wx, wy, wz] = this.wind;\r\n      let N = this.N.data,F = this.F.data,V = this.V.data,X = this.X.data;\r\n      for (let i = 0, ii = 0, l = this.F.size; i < l; ++i, ii += 3) {\r\n        let nx = N[ii + 0];\r\n        let ny = N[ii + 1];\r\n        let nz = N[ii + 2];\r\n        let vx = V[ii + 0];\r\n        let vy = V[ii + 1];\r\n        let vz = V[ii + 2];\r\n        let vwx = vx - wx;\r\n        let vwy = vy - wy;\r\n        let vwz = vz - wz;\r\n        let vwdn = vwx * nx + vwy * ny + vwz * nz;\r\n        let s = Options.dampAir * vwdn;\r\n        F[ii + 0] -= nx * s;\r\n        F[ii + 1] -= ny * s;\r\n        F[ii + 2] -= nz * s;\r\n      }\r\n      for (let i = 0; i < this.springs.length; ++i) {\r\n        this.preSolveSpring(this.springs[i]);\r\n      }\r\n    }\r\n\r\n    preSolveSpring(s) {\r\n      const I00 = 1.0,I01 = 0.0,I02 = 0.0;\r\n      const I10 = 0.0,I11 = 1.0,I12 = 0.0;\r\n      const I20 = 0.0,I21 = 0.0,I22 = 1.0;\r\n\r\n      let sa = s.a * 3 >>> 0;\r\n      let sb = s.b * 3 >>> 0;\r\n      let rest = +s.rest;\r\n      let damp = +Options.dampSpring;\r\n\r\n      let dFdX = this.dFdX.data,dFdV = this.dFdV.data;\r\n      let F = this.F.data,X = this.X.data,V = this.V.data;\r\n\r\n      let eX = X[sb + 0] - X[sa + 0],\r\n      eY = X[sb + 1] - X[sa + 1],\r\n      eZ = X[sb + 2] - X[sa + 2];\r\n\r\n      let length = Math.sqrt(eX * eX + eY * eY + eZ * eZ);\r\n      let il = 1.0 / (length + 1e-37);\r\n\r\n      let dx = eX * il,dy = eY * il,dz = eZ * il;\r\n      let velX = V[sb + 0] - V[sa + 0];\r\n      let velY = V[sb + 1] - V[sa + 1];\r\n      let velZ = V[sb + 2] - V[sa + 2];\r\n\r\n      let k = +SpringConstants[s.type];\r\n      let velDotDir = velX * dx + velY * dy + velZ * dz;\r\n      let fa = k * (length - rest) + damp * velDotDir;\r\n      let fX = dx * fa,fY = dy * fa,fZ = dz * fa;\r\n\r\n      F[sa + 0] += fX;F[sa + 1] += fY;F[sa + 2] += fZ;\r\n      F[sb + 0] -= fX;F[sb + 1] -= fY;F[sb + 2] -= fZ;\r\n\r\n      let rl = rest / length < 1.0 ? rest / length : 1.0;\r\n      // outer(dir, dir)\r\n      let dp00 = dx * dx,dp01 = dx * dy,dp02 = dx * dz;\r\n      let dp10 = dx * dy,dp11 = dy * dy,dp12 = dy * dz;\r\n      let dp20 = dx * dz,dp21 = dy * dz,dp22 = dz * dz;\r\n\r\n      let dFdXs00 = -k * ((I00 - dp00) * rl - I00),dFdXs01 = -k * ((I01 - dp01) * rl - I01),dFdXs02 = -k * ((I02 - dp02) * rl - I02);\r\n      let dFdXs10 = -k * ((I10 - dp10) * rl - I10),dFdXs11 = -k * ((I11 - dp11) * rl - I11),dFdXs12 = -k * ((I12 - dp12) * rl - I12);\r\n      let dFdXs20 = -k * ((I20 - dp20) * rl - I20),dFdXs21 = -k * ((I21 - dp21) * rl - I21),dFdXs22 = -k * ((I22 - dp22) * rl - I22);\r\n\r\n      let m = damp * (velDotDir / Math.max(length, rest));\r\n      let dFdXd00 = (I00 - dp00) * m,dFdXd01 = (I01 - dp01) * m,dFdXd02 = (I02 - dp02) * m;\r\n      let dFdXd10 = (I10 - dp10) * m,dFdXd11 = (I11 - dp11) * m,dFdXd12 = (I12 - dp12) * m;\r\n      let dFdXd20 = (I20 - dp20) * m,dFdXd21 = (I21 - dp21) * m,dFdXd22 = (I22 - dp22) * m;\r\n\r\n      let dFdX00 = dFdXs00 + dFdXd00,dFdX01 = dFdXs01 + dFdXd01,dFdX02 = dFdXs02 + dFdXd02;\r\n      let dFdX10 = dFdXs10 + dFdXd10,dFdX11 = dFdXs11 + dFdXd11,dFdX12 = dFdXs12 + dFdXd12;\r\n      let dFdX20 = dFdXs20 + dFdXd20,dFdX21 = dFdXs21 + dFdXd21,dFdX22 = dFdXs22 + dFdXd22;\r\n\r\n      let dFdV00 = dp00 * damp,dFdV01 = dp01 * damp,dFdV02 = dp02 * damp;\r\n      let dFdV10 = dp10 * damp,dFdV11 = dp11 * damp,dFdV12 = dp12 * damp;\r\n      let dFdV20 = dp20 * damp,dFdV21 = dp21 * damp,dFdV22 = dp22 * damp;\r\n\r\n      let mAA = s.a * 9,mAB = s.iab * 9,mBB = s.b * 9,mBA = s.iba * 9;\r\n\r\n      dFdX[mAA + 0] -= dFdX00;dFdX[mAA + 1] -= dFdX01;dFdX[mAA + 2] -= dFdX02;\r\n      dFdX[mAA + 3] -= dFdX10;dFdX[mAA + 4] -= dFdX11;dFdX[mAA + 5] -= dFdX12;\r\n      dFdX[mAA + 6] -= dFdX20;dFdX[mAA + 7] -= dFdX21;dFdX[mAA + 8] -= dFdX22;\r\n\r\n      dFdX[mBB + 0] -= dFdX00;dFdX[mBB + 1] -= dFdX01;dFdX[mBB + 2] -= dFdX02;\r\n      dFdX[mBB + 3] -= dFdX10;dFdX[mBB + 4] -= dFdX11;dFdX[mBB + 5] -= dFdX12;\r\n      dFdX[mBB + 6] -= dFdX20;dFdX[mBB + 7] -= dFdX21;dFdX[mBB + 8] -= dFdX22;\r\n\r\n      dFdX[mAB + 0] += dFdX00;dFdX[mAB + 1] += dFdX01;dFdX[mAB + 2] += dFdX02;\r\n      dFdX[mAB + 3] += dFdX10;dFdX[mAB + 4] += dFdX11;dFdX[mAB + 5] += dFdX12;\r\n      dFdX[mAB + 6] += dFdX20;dFdX[mAB + 7] += dFdX21;dFdX[mAB + 8] += dFdX22;\r\n\r\n      dFdX[mBA + 0] += dFdX00;dFdX[mBA + 1] += dFdX01;dFdX[mBA + 2] += dFdX02;\r\n      dFdX[mBA + 3] += dFdX10;dFdX[mBA + 4] += dFdX11;dFdX[mBA + 5] += dFdX12;\r\n      dFdX[mBA + 6] += dFdX20;dFdX[mBA + 7] += dFdX21;dFdX[mBA + 8] += dFdX22;\r\n\r\n      dFdV[mAA + 0] -= dFdV00;dFdV[mAA + 1] -= dFdV01;dFdV[mAA + 2] -= dFdV02;\r\n      dFdV[mAA + 3] -= dFdV10;dFdV[mAA + 4] -= dFdV11;dFdV[mAA + 5] -= dFdV12;\r\n      dFdV[mAA + 6] -= dFdV20;dFdV[mAA + 7] -= dFdV21;dFdV[mAA + 8] -= dFdV22;\r\n\r\n      dFdV[mBB + 0] -= dFdV00;dFdV[mBB + 1] -= dFdV01;dFdV[mBB + 2] -= dFdV02;\r\n      dFdV[mBB + 3] -= dFdV10;dFdV[mBB + 4] -= dFdV11;dFdV[mBB + 5] -= dFdV12;\r\n      dFdV[mBB + 6] -= dFdV20;dFdV[mBB + 7] -= dFdV21;dFdV[mBB + 8] -= dFdV22;\r\n\r\n      dFdV[mAB + 0] += dFdV00;dFdV[mAB + 1] += dFdV01;dFdV[mAB + 2] += dFdV02;\r\n      dFdV[mAB + 3] += dFdV10;dFdV[mAB + 4] += dFdV11;dFdV[mAB + 5] += dFdV12;\r\n      dFdV[mAB + 6] += dFdV20;dFdV[mAB + 7] += dFdV21;dFdV[mAB + 8] += dFdV22;\r\n\r\n      dFdV[mBA + 0] += dFdV00;dFdV[mBA + 1] += dFdV01;dFdV[mBA + 2] += dFdV02;\r\n      dFdV[mBA + 3] += dFdV10;dFdV[mBA + 4] += dFdV11;dFdV[mBA + 5] += dFdV12;\r\n      dFdV[mBA + 6] += dFdV20;dFdV[mBA + 7] += dFdV21;dFdV[mBA + 8] += dFdV22;\r\n    }\r\n\r\n\r\n\r\n    conjGradFilt(Xv, Am, Bv, Sm) {\r\n      const epsilon = 0.02;\r\n      const loopLim = 100;\r\n      function filter(v, s) {\r\n        for (let i = 0, i9 = 0, size = s.size, V = v.data, S = s.data; i < size; ++i, i9 += 9) {\r\n          let r = s.posns[i * 2] * 3 >>> 0;\r\n          let s00 = +S[i9 + 0],s01 = +S[i9 + 1],s02 = +S[i9 + 2];\r\n          let s10 = +S[i9 + 3],s11 = +S[i9 + 4],s12 = +S[i9 + 5];\r\n          let s20 = +S[i9 + 6],s21 = +S[i9 + 7],s22 = +S[i9 + 8];\r\n          let v0 = V[r + 0],v1 = V[r + 1],v2 = V[r + 2];\r\n          V[r + 0] = v0 * s00 + v1 * s10 + v2 * s20;\r\n          V[r + 1] = v0 * s01 + v1 * s11 + v2 * s21;\r\n          V[r + 2] = v0 * s02 + v1 * s12 + v2 * s22;\r\n        }\r\n      }\r\n      const size = Bv.size;\r\n      const size3 = size * 3;\r\n      let q = this.tmpQ,d = this.tmpD,tmp = this.tmpT,r = this.tmpR;\r\n      let X = Xv.data,Q = q.data,D = d.data,B = Bv.data,T = tmp.data,R = r.data;\r\n\r\n      for (let i = 0; i < size3; ++i) {\r\n        Q[i] = D[i] = T[i] = R[i] = 0.0;\r\n      }\r\n\r\n      _utils__WEBPACK_IMPORTED_MODULE_3__[\"default\"].mul(tmp, Am, Xv);\r\n      for (let i = 0; i < size3; ++i) {\r\n        R[i] = B[i] - T[i];\r\n      }\r\n      filter(r, Sm);\r\n      d.copy(r);\r\n      let s = _utils__WEBPACK_IMPORTED_MODULE_3__[\"default\"].dot(r, r);\r\n\r\n      let sTarg = s * epsilon * epsilon;\r\n      let loops = 0;\r\n      while (s > sTarg && loops++ < loopLim) {\r\n        _utils__WEBPACK_IMPORTED_MODULE_3__[\"default\"].mul(q, Am, d);\r\n        filter(q, Sm);\r\n        let a = s / _utils__WEBPACK_IMPORTED_MODULE_3__[\"default\"].dot(d, q);\r\n        for (let i = 0; i < size3; ++i) {\r\n          X[i] += D[i] * a;\r\n        }\r\n        //filterH(X,H)\r\n        if (loops % 50 === 0) {// || H.length !== 0) {\r\n            _utils__WEBPACK_IMPORTED_MODULE_3__[\"default\"].mul(tmp, Am, Xv);\r\n          for (let i = 0; i < size3; ++i) {\r\n            R[i] = B[i] - T[i];\r\n          }\r\n          filter(r, Sm);\r\n        } else\r\n        {\r\n          for (let i = 0; i < size3; ++i) {\r\n            R[i] -= Q[i] * a;\r\n          }\r\n        }\r\n        let lastS = s;\r\n        s = _utils__WEBPACK_IMPORTED_MODULE_3__[\"default\"].dot(r, r);\r\n        let sr = s / lastS;\r\n        for (let i = 0; i < size3; ++i) {\r\n          D[i] = R[i] + D[i] * sr;\r\n        }\r\n        filter(d, Sm);\r\n      }\r\n      return loops < loopLim;\r\n    }\r\n\r\n\r\n    simulate(dt) {\r\n      if (dt <= 0.0) {\r\n        return;\r\n      }\r\n      dt = +dt;\r\n      this.calcForces();\r\n      const dtSqr = dt * dt;\r\n\r\n      const size = this.X.size;\r\n      const size3 = size * 3 >>> 0;\r\n\r\n      let B = this.tmpB;\r\n      let dFdXmV = this.tmpdFdXmV;\r\n\r\n      this.dV.zero();\r\n      for (let i = 0, ii = 0, l = this.S.size, V = this.V.data; i < l; ++i, ii += 2) {\r\n        let c = this.S.posns[ii + 1] * 3 >>> 0;\r\n        V[c + 0] = 0.0;V[c + 1] = 0.0;V[c + 2] = 0.0;\r\n      }\r\n\r\n      this.A.initDiag(1.0);\r\n      for (let i = 0, l = this.A.size * 9, A = this.A.data, dFdV = this.dFdV.data, dFdX = this.dFdX.data; i < l; ++i) {\r\n        A[i] -= dFdV[i] * dt + dFdX[i] * dtSqr;\r\n      }\r\n\r\n      _utils__WEBPACK_IMPORTED_MODULE_3__[\"default\"].mul(dFdXmV, this.dFdX, this.V);\r\n\r\n      for (let i = 0, F = this.F.data; i < size3; ++i) {\r\n        B.data[i] = F[i] * dt + dFdXmV.data[i] * dtSqr;\r\n      }\r\n\r\n      this.conjGradFilt(this.dV, this.A, B, this.S);\r\n\r\n      for (let i = 0, X = this.X.data, V = this.V.data, dV = this.dV.data; i < size3; ++i) {\r\n        V[i] += dV[i];\r\n      }\r\n      for (let i = 0, X = this.X.data, V = this.V.data, dV = this.dV.data; i < size3; ++i) {\r\n        X[i] += V[i] * dt;\r\n      }\r\n\r\n\r\n      for (let i = 0, Sp = this.S.posns, sSize = this.S.size, V = this.V.data; i < sSize; ++i) {\r\n        let ci = Sp[i * 2 + 1] * 3 >>> 0;\r\n        V[ci + 0] = V[ci + 1] = V[ci + 2] = 0.0;\r\n      }\r\n      this.awake = _utils__WEBPACK_IMPORTED_MODULE_3__[\"default\"].dot(this.V, this.V) < Options.sleepThreshold ? this.awake - 1 : Options.sleepCount;\r\n      this.nancheckAll();\r\n    }\r\n    populateVertexBuffer(buf) {\r\n      let pos = this.X.data;\r\n      let nor = this.N.data;\r\n      let tex = this.uvs;\r\n\r\n      let size = this.X.size;\r\n\r\n      for (let i = 0, i3 = 0, i2 = 0, i8 = 0; i < size; ++i, i2 += 2, i3 += 3, i8 += 8) {\r\n        buf[i8 + 0] = pos[i3 + 0];\r\n        buf[i8 + 1] = pos[i3 + 1];\r\n        buf[i8 + 2] = pos[i3 + 2];\r\n        buf[i8 + 3] = nor[i3 + 0];\r\n        buf[i8 + 4] = nor[i3 + 1];\r\n        buf[i8 + 5] = nor[i3 + 2];\r\n        buf[i8 + 6] = tex[i2 + 0];\r\n        buf[i8 + 7] = tex[i2 + 1];\r\n      }\r\n\r\n    }\r\n\r\n    nancheckAll() {\r\n      if (!DEBUG) return;\r\n      for (let i = 0; i < this.Xb.length; ++i) {if (+this.Xb[i] !== this.Xb[i]) {console.error(\"NaNCheck Xb failed\");debugger;}}\r\n      for (let i = 0; i < this.M.length; ++i) {if (+this.M[i] !== this.M[i]) {console.error(\"NaNCheck M failed\");debugger;}}\r\n      this.X.nanCheck();\r\n      this.V.nanCheck();\r\n      this.N.nanCheck();\r\n      this.P.nanCheck();\r\n      this.F.nanCheck();\r\n      this.dV.nanCheck();\r\n\r\n      this.A.nanCheck();\r\n      this.dFdX.nanCheck();\r\n      this.dFdV.nanCheck();\r\n      this.S.nanCheck();\r\n\r\n      this.tmpB.nanCheck();\r\n      this.tmpdFdXmV.nanCheck();\r\n      this.tmpQ.nanCheck();\r\n      this.tmpD.nanCheck();\r\n      this.tmpT.nanCheck();\r\n      this.tmpR.nanCheck();\r\n    }}\n\n//# sourceURL=webpack:///./src/cloth.js?");

/***/ }),

/***/ "./src/main.js":
/*!*********************!*\
  !*** ./src/main.js ***!
  \*********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _cloth__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cloth */ \"./src/cloth.js\");\n\n\n\n(function(window) {\n  let DEBUG = false;\n  Sim.DEBUG = DEBUG;\n  let Options = {\n    gravity: -9.8,\n    structK: 100000,\n    shearK: 5000,\n    bendK: 1000,\n    dampSpring: 10,\n    dampAir: 5,\n    clothWidth: 16,\n    clothHeight: 16,\n    mass: 1.0,\n    sleepThreshold: 0.001,\n    sleepCount: 100,\n    tension: 1.0,\n    timeStep: 0.016,\n    pinned: {\n        bottomLeft: false,\n        bottomRight: false,\n        topLeft: true,\n        topRight: true\n    },\n    dynamicWind: true,\n    wind: [0.0, 0.0, 0.0] // if not dynamic\n  };\n  \n  \n  function run(clothImage) {\n      Sim.init();\n      \n      let cloth = new _cloth__WEBPACK_IMPORTED_MODULE_0__[\"default\"](Options.clothWidth, Options.clothHeight, 1.0);\n      cloth.wind[0] = -1.0; cloth.wind[2] = 0.4;\n      let {clothWidth, clothHeight} = Options;\n      for (let i = 0; i < cloth.X.size; ++i) \n          cloth.X.data[i*3+2] -= 1.75;\n      cloth.wind[0] = Options.wind[0];\n      cloth.wind[1] = Options.wind[1];\n      cloth.wind[2] = Options.wind[2];\n      let clothDt = Options.timeStep;\n      let selection = 0;\n      let shader = Sim.createShader(\"fs\", \"vs\", {a_position: 0, a_normal: 1, a_color: 2});\n      let vertexBuffer = new Float32Array(cloth.X.size*8);\n      let gl = Sim.gl;\n      let clothTexture = gl.createTexture();\n      \n      gl.bindTexture(gl.TEXTURE_2D, clothTexture);\n      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, clothImage);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);\n      gl.generateMipmap(gl.TEXTURE_2D);\n      Sim.checkGL(\"load texture\");\n      let viewMatrix = mat4.lookAt(null, 0,0,0, 0,0,-1, 0,1,0);\n      let modelMatrix = mat4.identity();\n      let vbo = gl.createBuffer();\n      let ibo = gl.createBuffer();\n      \n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ibo);\n    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, cloth.tris, gl.STATIC_DRAW);\n    Sim.checkGL('bufferData (tris)');\n  \n    gl.bindBuffer(gl.ARRAY_BUFFER, vbo);\n    gl.bufferData(gl.ARRAY_BUFFER, vertexBuffer, gl.DYNAMIC_DRAW);\n  \n    Sim.checkGL('bufferData (verts)');\n  \n      gl.enable(gl.DEPTH_TEST);\n      //gl.enable(gl.CULL_FACE);\n      let time = 0.0;\n      Sim.update = function(dt) {\n      Sim.canvas.width = Sim.width;\n      Sim.canvas.height = Sim.height;\n          time += dt;\n          gl.clearColor(0.2, 0.2, 0.2, 1.0);\n          gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n          let unsetPoint = -1;\n          if (Options.dynamicWind) {\n              let sx = Math.sin(time);\n              let sy = Math.cos(time);\n              cloth.wind[0] = sx;\n              cloth.wind[1] = 1.0;\n              cloth.wind[2] = sy;\n          }\n          if (!Sim.mouse.down) {\n              if (Sim.lastMouse.down && \n                  selection !== clothWidth*clothHeight-1 &&\n                  selection !== clothWidth*(clothHeight-1)) {\n                  cloth.pointStatusSet(selection, 0);\n              }\n              let [vx, vy, vz] = Sim.mouse.vec;\n              let bi = 0;\n              let bx = 0.0, by = 0.0, bz = 0.0;\n              for (let i = 1; i < cloth.X.size; ++i) {\n                  let cx = cloth.X.data[i*3+0];\n                  let cy = cloth.X.data[i*3+1];\n                  let cz = cloth.X.data[i*3+2];\n                  let l = Math.sqrt(cx*cx+cy*cy+cz*cz);\n                  if (l === 0) \n                      continue;\n                  cx /= l;\n                  cy /= l;\n                  cz /= l;\n                  if (vx*cx+vy*cy+vz*cz > bx*vx+by*vy+bz*vz) {\n                      bi = i;\n                      bx = cx;\n                      by = cy;\n                      bz = cz;\n                  }\n              }\n              selection = bi;\n          }\n          else {\n              if (!cloth.pointStatusSet(selection, -1)) {\n                  unsetPoint = selection;\n                  cloth.pointStatusSet(unsetPoint, 1);\n              }\n              let [vx, vy, vz] = Sim.mouse.vec;\n              let si = selection*3;\n              let cx = cloth.X.data[si+0], cy = cloth.X.data[si+1], cz = cloth.X.data[si+2];\n              let mul = (vx*cx+vy*cy+vz*cz)/(vx*vx+vy*vy+vz*vz);\n              cloth.X.data[si+0] = vx*mul;\n              cloth.X.data[si+1] = vy*mul;\n              cloth.X.data[si+2] = vz*mul;\n          }\n          cloth.simulate(clothDt);\n          \n          cloth.populateVertexBuffer(vertexBuffer);\n          \n          gl.bindBuffer(gl.ARRAY_BUFFER, vbo);\n      //gl.bufferData(gl.ARRAY_BUFFER, vertexBuffer, gl.DYNAMIC_DRAW);\n          gl.bufferSubData(gl.ARRAY_BUFFER, 0, vertexBuffer);\n          Sim.checkGL(\"upload vert data\");\n          gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ibo);\n          \n          gl.useProgram(shader.program);\n          \n        gl.enableVertexAttribArray(0); // posn\n        gl.enableVertexAttribArray(1); // norm\n        gl.enableVertexAttribArray(2); // texc\n        \n        Sim.checkGL(\"enableVertexAttribs\");\n        gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 4*8, 0); // pos\n        gl.vertexAttribPointer(1, 3, gl.FLOAT, false, 4*8, 3*4); // norm\n        gl.vertexAttribPointer(2, 2, gl.FLOAT, false, 4*8, 6*4); // texc\n          \n        Sim.checkGL(\"vertexAttribPointer\");\n        \n          gl.bindTexture(gl.TEXTURE_2D, clothTexture);\n          gl.activeTexture(gl.TEXTURE0);\n          Sim.checkGL(\"bind/active texture \");\n          Sim.setSceneUniforms(shader, viewMatrix);\n          Sim.setModelUniforms(shader, viewMatrix, modelMatrix);\n          \n          shader.setUniform1i('u_albedo', 0);\n        Sim.checkGL(\"set uniforms\");\n        gl.drawElements(gl.TRIANGLES, cloth.tris.length, gl.UNSIGNED_SHORT, 0);\n        Sim.checkGL(\"drawcall\");\n      }\n      //cloth.simulate(dt);\n      Sim.start();\n  }\n  \n  \n  \n  \n  //window.addEventListener('load', function() {\n      let img = new Image();\n      img.crossOrigin = \"anonymous\";\n      img.addEventListener('load', function() {\n          run(img);\n      })\n      img.addEventListener('error', function() {\n          alert('dang image didnt load');\n      });\n     // img.src = \"https://s3-us-west-2.amazonaws.com/s.cdpn.io/98205/GglYYNn.jpg\";\n     img.src = \"https://media.istockphoto.com/vectors/white-cloth-texture-vector-id484397768\";\n  //});\n  }(window))\n  \n\n//# sourceURL=webpack:///./src/main.js?");

/***/ }),

/***/ "./src/shaders/fragment.glsl":
/*!***********************************!*\
  !*** ./src/shaders/fragment.glsl ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"#version 300 es\\r\\n\\r\\nvarying vec3 v_view;\\r\\nvarying vec3 v_light;\\r\\nvarying vec3 v_normal;\\r\\nvarying vec2 v_texcoord;\\r\\nuniform sampler2D u_albedo;\\r\\nvoid main() {\\r\\n\\tvec3 n = normalize(v_normal);\\r\\n\\tvec3 l = normalize(v_light);\\r\\n\\tvec3 v = normalize(v_view);\\r\\n\\tvec3 r = reflect(-l, n);\\r\\n\\tvec3 albedo = pow(texture2D(u_albedo, v_texcoord).xyz, vec3(2.2));\\r\\n\\tvec3 diffuse = max(dot(n, l), 0.0)*albedo;\\r\\n\\tvec3 specular = vec3(0.0);//pow(max(dot(r, v), 0.0), 30.0) * u_lightColor;\\r\\n\\tvec3 color = saturate(u_ambient * albedo + diffuse + specular);\\r\\n\\tgl_FragColor = vec4(pow(color, vec3(1.0/2.2)), 1.0);\\r\\n}\");\n\n//# sourceURL=webpack:///./src/shaders/fragment.glsl?");

/***/ }),

/***/ "./src/shaders/vertex.glsl":
/*!*********************************!*\
  !*** ./src/shaders/vertex.glsl ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"#version 300 es\\r\\n\\r\\nattribute vec3 a_position;\\r\\nattribute vec3 a_normal;\\r\\nattribute vec2 a_texcoord;\\r\\n\\r\\nvarying vec3 v_view;\\r\\nvarying vec3 v_light;\\r\\nvarying vec3 v_normal;\\r\\nvarying vec2 v_texcoord;\\r\\n\\r\\nvoid main() {\\r\\n\\tvec4 p = u_modelView * vec4(a_position, 1.0);\\r\\n\\tv_normal = mat3(u_modelView) * a_normal;\\r\\n\\tv_view = -p.xyz;\\r\\n\\tv_light = u_lightPos - p.xyz;\\r\\n\\tv_texcoord = a_texcoord;\\r\\n\\tgl_Position = u_proj * p;\\r\\n}\");\n\n//# sourceURL=webpack:///./src/shaders/vertex.glsl?");

/***/ }),

/***/ "./src/spring.js":
/*!***********************!*\
  !*** ./src/spring.js ***!
  \***********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Spring; });\nclass Spring {\r\n    constructor(type, a, b, rest) {\r\n      this.type = type; // index into SpringConstants -- probably should just store k value here...\r\n      this.rest = rest;\r\n      this.a = a;\r\n      this.b = b;\r\n      this.iab = -1;\r\n      this.iba = -1;\r\n    }}\r\n\n\n//# sourceURL=webpack:///./src/spring.js?");

/***/ }),

/***/ "./src/utils.js":
/*!**********************!*\
  !*** ./src/utils.js ***!
  \**********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Utils; });\n/* harmony import */ var _shaders_vertex_glsl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./shaders/vertex.glsl */ \"./src/shaders/vertex.glsl\");\n/* harmony import */ var _shaders_fragment_glsl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./shaders/fragment.glsl */ \"./src/shaders/fragment.glsl\");\n\r\n\r\n\r\nclass Utils {\r\n\r\n  \r\n    static dot(a, b) {\r\n        let r = 0.0,sz = a.size;\r\n        console.assert(a.size === b.size);\r\n        for (let i = 0, size = a.size * 3; i < size; ++i) r += a.data[i] * b.data[i];\r\n        return r;\r\n      }\r\n\r\n      \r\n    static mul(out, mat, vec) {\r\n        if (!out) out = new BigVec3D(v.size);\r\n        else out.init(0, 0, 0);\r\n        let m = mat.data, v = vec.data, o = out.data;\r\n        for (let i = 0, sz = mat.size; i < sz; i++) {\r\n            let r = mat.posns[i*2+0], c = mat.posns[i*2+1];\r\n            let mi = (i * 9) >>> 0, vr = (r * 3) >>> 0, vc = (c * 3) >>> 0;\r\n          let mxx = +m[mi+0], mxy = +m[mi+1], mxz = +m[mi+2];\r\n          let myx = +m[mi+3], myy = +m[mi+4], myz = +m[mi+5];\r\n          let mzx = +m[mi+6], mzy = +m[mi+7], mzz = +m[mi+8];\r\n          let vx = +v[vr+0], vy = +v[vr+1], vz = +v[vr+2];\r\n          o[vc+0] += vx*mxx + vy*myx + vz*mzx;\r\n          o[vc+1] += vx*mxy + vy*myy + vz*mzy;\r\n          o[vc+2] += vx*mxz + vy*myz + vz*mzz;\r\n        }\r\n        return out;\r\n      }\r\n      \r\n      static  foreach2d(w, h, fn) {\r\n        for (let i = 0; i < h; ++i) {\r\n          for (let j = 0; j < w; ++j) {\r\n            fn(i, j);\r\n          }\r\n        }\r\n      }\r\n\r\n\r\n  static createVertexShader(gl) {\r\n    const vertexShader = gl.createShader(gl.VERTEX_SHADER)\r\n    \r\n    gl.shaderSource(vertexShader, _shaders_vertex_glsl__WEBPACK_IMPORTED_MODULE_0__[\"default\"])\r\n    gl.compileShader(vertexShader)\r\n\r\n    if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {\r\n      alert('vertex compilation failed: ' + gl.getShaderInfoLog(vertexShader));\r\n      gl.deleteShader(vertexShader);\r\n      return null;\r\n    }\r\n\r\n    return vertexShader\r\n  }\r\n\r\n  static createFragmentShader(gl) {\r\n    const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);\r\n    gl.shaderSource(fragmentShader, _shaders_fragment_glsl__WEBPACK_IMPORTED_MODULE_1__[\"default\"]);\r\n    gl.compileShader(fragmentShader);\r\n\r\n    if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {\r\n      alert('fragment compilation failed: ' + gl.getShaderInfoLog(fragmentShader));\r\n      gl.deleteShader(fragmentShader);\r\n      return null;\r\n    }\r\n\r\n    return fragmentShader\r\n  }\r\n\r\n  static createShaderProgram(gl) {\r\n\r\n    const shaderProgram = gl.createProgram();\r\n    gl.attachShader(shaderProgram, Utils.createVertexShader(gl));\r\n    gl.attachShader(shaderProgram, Utils.createFragmentShader(gl));\r\n    gl.linkProgram(shaderProgram);\r\n\r\n    if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {\r\n      alert('Unable to link the shader program: ' + gl.getProgramInfoLog(shaderProgram));\r\n      return null;\r\n    }\r\n\r\n    return shaderProgram;\r\n  }\r\n}\n\n//# sourceURL=webpack:///./src/utils.js?");

/***/ })

/******/ });